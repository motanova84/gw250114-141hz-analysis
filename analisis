

# Ahora corrijamos el script analizar_ringdown.py
cat > scripts/analizar_ringdown.py << 'EOL'
#!/usr/bin/env python3
"""
AnÃ¡lisis de componente en 141.7 Hz en el ringdown - CORREGIDO
"""
import h5py
import numpy as np
import matplotlib.pyplot as plt
from scipy import signal
import os

def cargar_datos_gwosc(archivo_hdf5):
    """Cargar datos desde archivo HDF5 de GWOSC (formato correcto)"""
    with h5py.File(archivo_hdf5, 'r') as hdf:
        # El formato de GWOSC tiene la estructura diferente
        strain = hdf['strain']['Strain'][:]
        meta = hdf['meta']
        gps_start = meta['GPSstart'][()]
        duration = meta['Duration'][()]
        sample_rate = meta['SampleRate'][()]
    
    tiempo = np.arange(len(strain)) / sample_rate + gps_start
    return tiempo, strain, sample_rate

def analizar_espectro(tiempo, datos, sample_rate, frecuencia_objetivo=141.7):
    """Analizar el espectro en busca de la frecuencia objetivo"""
    # Calcular FFT
    n = len(datos)
    freqs = np.fft.rfftfreq(n, d=1/sample_rate)
    fft_vals = np.fft.rfft(datos)
    potencia = np.abs(fft_vals)**2
    
    # Encontrar pico mÃ¡s cercano a la frecuencia objetivo
    idx_objetivo = np.argmin(np.abs(freqs - frecuencia_objetivo))
    freq_pico = freqs[idx_objetivo]
    potencia_pico = potencia[idx_objetivo]
    
    # Calcular significancia (SNR aproximado)
    noise_floor = np.median(potencia)
    snr = potencia_pico / noise_floor
    
    return freqs, potencia, freq_pico, potencia_pico, snr

def crear_graficos(tiempo, datos, freqs, potencia, freq_pico, snr, detector, output_dir):
    """Crear grÃ¡ficos de diagnÃ³stico"""
    fig, ((ax1, ax2), (ax3, ax4)) = plt.subplots(2, 2, figsize=(15, 10))
    
    # Serie temporal (solo mostramos una parte)
    ax1.plot(tiempo[:10000], datos[:10000], 'b-', linewidth=1)
    ax1.set_xlabel('Tiempo (s)')
    ax1.set_ylabel('Strain')
    ax1.set_title(f'SeÃ±al Temporal - {detector}')
    ax1.grid(True)
    
    # Espectro de potencia
    ax2.semilogy(freqs, potencia, 'b-', linewidth=1)
    ax2.axvline(141.7, color='r', linestyle='--', alpha=0.7, label='141.7 Hz objetivo')
    ax2.axvline(freq_pico, color='g', linestyle='--', alpha=0.7, label=f'Pico: {freq_pico:.1f} Hz')
    ax2.set_xlabel('Frecuencia (Hz)')
    ax2.set_ylabel('Potencia')
    ax2.set_title(f'Espectro (SNR: {snr:.2f})')
    ax2.legend()
    ax2.grid(True)
    ax2.set_xlim(100, 200)
    
    # Zoom alrededor de 141.7 Hz
    ax3.semilogy(freqs, potencia, 'b-', linewidth=1.5)
    ax3.axvline(141.7, color='r', linestyle='--', alpha=0.7, linewidth=2, label='141.7 Hz')
    ax3.set_xlabel('Frecuencia (Hz)')
    ax3.set_ylabel('Potencia')
    ax3.set_title('Zoom: 130-160 Hz')
    ax3.grid(True)
    ax3.set_xlim(130, 160)
    ax3.legend()
    
    # Histograma para ver distribuciÃ³n de potencia
    ax4.hist(np.log10(potencia + 1e-10), bins=50, alpha=0.7)
    ax4.axvline(np.log10(potencia_pico + 1e-10), color='r', linestyle='--', 
                label=f'Pico: {potencia_pico:.2e}')
    ax4.set_xlabel('log10(Potencia)')
    ax4.set_ylabel('Frecuencia')
    ax4.set_title('DistribuciÃ³n de Potencia (log)')
    ax4.legend()
    ax4.grid(True)
    
    plt.tight_layout()
    plt.savefig(f'{output_dir}/analisis_{detector}.png', dpi=150, bbox_inches='tight')
    plt.close()

def main():
    # ConfiguraciÃ³n
    output_dir = '../results/figures'
    os.makedirs(output_dir, exist_ok=True)
    
    # Para GW150914 (datos reales de control)
    archivo_h1 = '../data/raw/H1-GW150914-32s.hdf5'
    
    if os.path.exists(archivo_h1):
        print("Analizando datos de GW150914 (control)...")
        
        # Cargar datos con formato correcto
        tiempo, strain, sample_rate = cargar_datos_gwosc(archivo_h1)
        print(f"Sample rate: {sample_rate} Hz")
        print(f"DuraciÃ³n: {len(strain)/sample_rate:.1f} segundos")
        print(f"Tiempo GPS inicio: {tiempo[0]:.1f}")
        
        # Encontrar el tiempo del merger (1126259462.423)
        merger_time = 1126259462.423
        merger_index = np.argmin(np.abs(tiempo - merger_time))
        
        # Analizar espectro completo
        freqs, potencia, freq_pico, potencia_pico, snr = analizar_espectro(
            tiempo, strain, sample_rate
        )
        
        print(f"\nResultados para H1 - GW150914:")
        print(f"  - Frecuencia del pico mÃ¡s cercano: {freq_pico:.2f} Hz")
        print(f"  - SNR aproximado: {snr:.2f}")
        print(f"  - Â¿Coincide con 141.7 Hz? {'SÃ' if abs(freq_pico-141.7)<1 else 'NO'}")
        
        # Crear grÃ¡ficos
        crear_graficos(tiempo, strain, freqs, potencia, freq_pico, snr, 'H1_GW150914', output_dir)
        print(f"GrÃ¡ficos guardados en {output_dir}/")
    
    else:
        print("Â¡Los datos de GW150914 no se encontraron!")
        print("Ejecuta primero: python scripts/descargar_datos.py")

if __name__ == "__main__":
    main()
EOL

# Ahora ejecutemos el anÃ¡lisis corregido
python scripts/analizar_ringdown.py

# TambiÃ©n actualicemos el analizador noÃ©sico para usar el formato correcto
cat > scripts/analisis_noesico.py << 'EOL'
#!/usr/bin/env python3
"""
ANÃLISIS DE RESONANCIA NOÃ‰SICA - 141.7001 Hz - CORREGIDO
"""
import h5py
import numpy as np
import matplotlib.pyplot as plt
from scipy import signal
import os

class AnalizadorNoesico:
    def __init__(self, frecuencia_objetivo=141.7001):
        self.frecuencia_objetivo = frecuencia_objetivo
        self.frecuencias_armonicas = self.calcular_armonicos()
        
    def calcular_armonicos(self):
        """Calcular armÃ³nicos de la frecuencia noÃ©sica"""
        return [self.frecuencia_objetivo * n for n in [1, 1.618, 3.1416, 4.669]]
    
    def cargar_datos(self, archivo_hdf5):
        """Cargar datos desde archivo HDF5 de GWOSC"""
        with h5py.File(archivo_hdf5, 'r') as hdf:
            strain = hdf['strain']['Strain'][:]
            meta = hdf['meta']
            sample_rate = meta['SampleRate'][()]
        return strain, sample_rate
    
    def analizar_resonancia(self, data, sample_rate):
        """AnÃ¡lisis completo de resonancia"""
        print(f"ðŸ”­ Analizando resonancia en {self.frecuencia_objetivo} Hz...")
        
        # Transformada de Fourier
        freqs = np.fft.rfftfreq(len(data), 1/sample_rate)
        fft_val = np.fft.rfft(data)
        espectro = np.abs(fft_val)**2
        
        # Buscar pico exacto en 141.7001 Hz
        idx_target = np.argmin(np.abs(freqs - self.frecuencia_objetivo))
        potencia_target = espectro[idx_target]
        
        # AnÃ¡lisis de armÃ³nicos
        resultados_armonicos = {}
        for arm in self.frecuencias_armonicas:
            idx_arm = np.argmin(np.abs(freqs - arm))
            resultados_armonicos[arm] = {
                'potencia': espectro[idx_arm],
                'snr': espectro[idx_arm] / np.median(espectro)
            }
        
        return {
            'frecuencia_objetivo': self.frecuencia_objetivo,
            'potencia': potencia_target,
            'snr': potencia_target / np.median(espectro),
            'armonicos': resultados_armonicos,
            'frecuencias': freqs,
            'espectro': espectro
        }
    
    def visualizar_resonancia(self, data, sample_rate, output_path):
        """VisualizaciÃ³n completa de la resonancia"""
        resultados = self.analizar_resonancia(data, sample_rate)
        
        fig, axes = plt.subplots(2, 1, figsize=(12, 10))
        
        # Espectro de potencia
        axes[0].semilogy(resultados['frecuencias'], resultados['espectro'], 'r-')
        for arm in self.frecuencias_armonicas:
            axes[0].axvline(arm, color='g', linestyle='--', alpha=0.7, label=f'ArmÃ³nico {arm:.1f} Hz')
        axes[0].axvline(self.frecuencia_objetivo, color='m', linewidth=2, linestyle='-', 
                       label=f'Objetivo {self.frecuencia_objetivo} Hz')
        axes[0].set_xlim(100, 200)
        axes[0].set_xlabel('Frecuencia (Hz)')
        axes[0].set_ylabel('Potencia')
        axes[0].set_title(f'Espectro de Potencia - SNR: {resultados["snr"]:.2f}')
        axes[0].legend()
        axes[0].grid(True)
        
        # Espectrograma
        f, t, Sxx = signal.spectrogram(data, fs=sample_rate, nperseg=1024, noverlap=900)
        im = axes[1].pcolormesh(t, f, 10*np.log10(Sxx + 1e-10), shading='gouraud', cmap='viridis')
        axes[1].axhline(self.frecuencia_objetivo, color='m', linewidth=2)
        for arm in self.frecuencias_armonicas:
            axes[1].axhline(arm, color='g', linestyle='--', alpha=0.7)
        axes[1].set_ylim(130, 160)
        axes[1].set_xlabel('Tiempo (s)')
        axes[1].set_ylabel('Frecuencia (Hz)')
        axes[1].set_title('Espectrograma - Zona de Resonancia')
        plt.colorbar(im, ax=axes[1], label='dB')
        
        plt.tight_layout()
        plt.savefig(output_path, dpi=300, bbox_inches='tight')
        plt.close()
        
        return resultados

def main():
    analizador = AnalizadorNoesico()
    print("ðŸŒ€ Analizador NoÃ©sico inicializado")
    print(f"ðŸŽ¯ Frecuencia objetivo: {analizador.frecuencia_objetivo} Hz")
    print(f"ðŸ“Š ArmÃ³nicos: {analizador.frecuencias_armonicas}")
    
    # Analizar datos de H1
    archivo_h1 = '../data/raw/H1-GW150914-32s.hdf5'
    if os.path.exists(archivo_h1):
        print("\nðŸ“¡ Analizando datos de Hanford (H1)...")
        data, sample_rate = analizador.cargar_datos(archivo_h1)
        
        # Ejecutar anÃ¡lisis
        output_path = '../results/figures/resonancia_noesica_H1.png'
        resultados = analizador.visualizar_resonancia(data, sample_rate, output_path)
        
        print(f"\nðŸ“Š Resultados del anÃ¡lisis noÃ©sico:")
        print(f"   SNR en {resultados['frecuencia_objetivo']} Hz: {resultados['snr']:.2f}")
        print(f"   Potencia: {resultados['potencia']:.2e}")
        
        print("\nðŸŽµ ArmÃ³nicos detectados:")
        for freq, datos in resultados['armonicos'].items():
            print(f"   {freq:.1f} Hz: SNR = {datos['snr']:.2f}")
            
        print(f"\nðŸ’¾ GrÃ¡fico guardado en: {output_path}")
    else:
        print("Â¡Datos no encontrados! Ejecuta primero: python scripts/descargar_datos.py")

if __name__ == "__main__":
    main()
EOL

# Ejecutar el analizador noÃ©sico corregido
python scripts/analisis_noesico.py

# Agregar los cambios al repositorio
git add scripts/analizar_ringdown.py scripts/analisis_noesico.py
git commit -m "Corregir scripts para formato GWOSC y mejorar anÃ¡lisis noÃ©sico"
git push origin main
